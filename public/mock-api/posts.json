[
  {
    "id": "1",
    "title": "Getting Started with React 18: New Features and Best Practices",
    "content": "React 18 introduces several groundbreaking features that enhance both developer experience and application performance. The most notable addition is concurrent rendering, which allows React to prepare multiple versions of the UI simultaneously.\n\n## Concurrent Rendering\nThis enables features like automatic batching of state updates, which reduces re-renders and significantly improves performance in complex applications. The new Suspense API for data fetching makes handling asynchronous operations more intuitive and declarative.\n\n## Transition APIs\nTransition APIs help differentiate between urgent and non-urgent updates, ensuring that high-priority interactions (like typing in an input field) remain responsive even during heavy computations.\n\n## Practical Examples\n```jsx\nimport { startTransition } from 'react';\n\n// Mark non-urgent updates\nstartTransition(() => {\n  setNonUrgentState(newValue);\n});\n```\n\nThese features work together to create smoother user experiences and more maintainable codebases. The key takeaway is that React 18 provides better tools for building responsive applications without sacrificing developer experience.",
    "excerpt": "Explore React 18's concurrent rendering, automatic batching, and new Suspense features with practical examples and migration strategies.",
    "authorId": "1",
    "category": "React",
    "tags": ["react", "javascript", "frontend", "web-development", "typescript", "performance"],
    "publishedAt": "2024-01-15T10:30:00Z",
    "updatedAt": "2024-01-20T14:15:00Z",
    "readTime": 8,
    "likes": 342,
    "bookmarks": 156,
    "views": 5210,
    "featuredImage": "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=1200&h=600&fit=crop",
    "isFeatured": true,
    "status": "published"
  },
  {
    "id": "2",
    "title": "TypeScript Best Practices for 2024: Write Cleaner, Safer Code",
    "content": "TypeScript continues to evolve, and staying up-to-date with best practices is crucial for maintaining clean, scalable code.\n\n## Strict Mode\nOne key practice is enabling strict mode, which activates all strict type-checking options. This catches potential errors early in development.\n\n```typescript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true\n  }\n}\n```\n\n## Utility Types\nUtility types like `Partial<T>`, `Required<T>`, and `Pick<T, K>` help create derived types without duplication:\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  role: string;\n}\n\ntype UserUpdate = Partial<User>;\ntype UserPublicInfo = Pick<User, 'id' | 'name'>;\n```\n\n## Conditional Types\nAdvanced patterns using conditional types enable more precise type definitions:\n\n```typescript\ntype Response<T> = T extends Array<any> \n  ? { data: T; total: number }\n  : { data: T };\n```\n\nAlways prefer interfaces for object shapes and use type aliases for unions, tuples, and other complex types.",
    "excerpt": "Discover the latest TypeScript patterns, utility types, and strict configuration options to write more maintainable and type-safe code.",
    "authorId": "2",
    "category": "TypeScript",
    "tags": ["typescript", "javascript", "programming", "best-practices", "web-development", "strict-typing"],
    "publishedAt": "2024-01-20T14:45:00Z",
    "updatedAt": "2024-01-25T09:30:00Z",
    "readTime": 10,
    "likes": 489,
    "bookmarks": 232,
    "views": 8920,
    "featuredImage": "https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=1200&h=600&fit=crop",
    "isFeatured": true,
    "status": "published"
  },
  {
    "id": "3",
    "title": "Mastering Tailwind CSS: Advanced Techniques and Customization",
    "content": "Tailwind CSS has revolutionized how we write CSS by providing a utility-first approach that promotes consistency and reduces CSS bloat.\n\n## Customizing Your Theme\nThe key to mastering Tailwind is understanding its design system. Customize your theme through `tailwind.config.js`:\n\n```javascript\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        brand: {\n          50: '#f0f9ff',\n          100: '#e0f2fe',\n          // ... brand colors\n        }\n      }\n    }\n  }\n}\n```\n\n## JIT Mode\nThe Just-In-Time (JIT) mode generates styles on-demand, resulting in significantly smaller production bundles:\n\n```javascript\n// tailwind.config.js\nmodule.exports = {\n  mode: 'jit',\n  // ...\n}\n```\n\n## Component Extraction\nUse `@apply` carefully for truly reusable component styles. Combine Tailwind with component frameworks like React for a powerful, maintainable styling solution.",
    "excerpt": "Learn advanced techniques for customizing and extending Tailwind CSS to build consistent, beautiful interfaces with minimal CSS.",
    "authorId": "3",
    "category": "Tailwind",
    "tags": ["tailwind", "css", "styling", "frontend", "design", "utility-first", "responsive"],
    "publishedAt": "2024-01-25T09:15:00Z",
    "updatedAt": "2024-01-30T11:20:00Z",
    "readTime": 7,
    "likes": 256,
    "bookmarks": 178,
    "views": 6310,
    "featuredImage": "https://images.unsplash.com/photo-1655720828016-291a2e5565f3?w=1200&h=600&fit=crop",
    "isFeatured": false,
    "status": "published"
  },
  {
    "id": "4",
    "title": "Building REST APIs with Node.js and Express: Complete Guide",
    "content": "Building robust REST APIs with Node.js and Express requires careful consideration of architecture, security, and performance.\n\n## Project Structure\nOrganize your API following the MVC pattern:\n```\nsrc/\n├── controllers/\n├── models/\n├── routes/\n├── middleware/\n└── utils/\n```\n\n## Error Handling\nImplement centralized error handling middleware:\n```javascript\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(err.status || 500).json({\n    error: {\n      message: err.message,\n      status: err.status || 500\n    }\n  });\n});\n```\n\n## Security Best Practices\nAlways implement:\n- Input validation\n- Rate limiting\n- CORS configuration\n- HTTPS enforcement\n- Helmet.js for security headers\n\n## Performance Optimization\n- Implement caching\n- Use compression\n- Database connection pooling\n- Async/await pattern",
    "excerpt": "A comprehensive guide to building secure, scalable REST APIs with Node.js, Express, and best practices for production environments.",
    "authorId": "4",
    "category": "Backend",
    "tags": ["nodejs", "express", "api", "backend", "rest", "javascript", "security"],
    "publishedAt": "2024-02-01T13:20:00Z",
    "updatedAt": "2024-02-05T16:45:00Z",
    "readTime": 12,
    "likes": 189,
    "bookmarks": 94,
    "views": 4210,
    "featuredImage": "https://images.unsplash.com/photo-1627398242454-45a1465c2479?w=1200&h=600&fit=crop",
    "isFeatured": true,
    "status": "published"
  },
  {
    "id": "5",
    "title": "Docker for Web Developers: From Basics to Production",
    "content": "Docker has become essential for modern web development workflows, enabling consistent environments from development to production.\n\n## Dockerfile Basics\nCreate a Dockerfile for a Node.js application:\n```dockerfile\nFROM node:18-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nEXPOSE 3000\nCMD [\"node\", \"server.js\"]\n```\n\n## Docker Compose\nUse Docker Compose for multi-container applications:\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n  db:\n    image: postgres:15\n    environment:\n      - POSTGRES_PASSWORD=secret\n```\n\n## Best Practices\n- Use multi-stage builds\n- Implement health checks\n- Configure proper logging\n- Set resource limits\n- Use .dockerignore file",
    "excerpt": "Learn Docker fundamentals, containerization strategies, and best practices for deploying web applications in production.",
    "authorId": "5",
    "category": "DevOps",
    "tags": ["docker", "devops", "containers", "deployment", "ci-cd", "infrastructure"],
    "publishedAt": "2024-02-10T11:30:00Z",
    "updatedAt": "2024-02-15T14:20:00Z",
    "readTime": 9,
    "likes": 312,
    "bookmarks": 167,
    "views": 5890,
    "featuredImage": "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=1200&h=600&fit=crop",
    "isFeatured": false,
    "status": "published"
  },
  {
    "id": "6",
    "title": "Next.js 14: Server Components and App Router Deep Dive",
    "content": "Next.js 14 introduces groundbreaking features with the App Router and Server Components that change how we think about React applications.\n\n## Server Components\nServer Components render on the server, reducing bundle size and improving performance:\n\n```javascript\n// app/page.js - Server Component by default\nexport default async function Home() {\n  const data = await fetchData();\n  return <DataDisplay data={data} />;\n}\n```\n\n## App Router Structure\nThe new App Router provides file-based routing with enhanced features:\n```\napp/\n├── layout.js        # Root layout\n├── page.js          # Home page\n├── about/\n│   ├── page.js      # About page\n│   └── layout.js    # Nested layout\n└── blog/\n    └── [slug]/\n        └── page.js  # Dynamic route\n```\n\n## Performance Benefits\n- Automatic code splitting\n- Streaming server rendering\n- Built-in image optimization\n- Font optimization\n\n## Migration Tips\n- Start with static pages\n- Gradually adopt Server Components\n- Use Suspense boundaries\n- Leverage caching strategies",
    "excerpt": "Explore Next.js 14's revolutionary Server Components, App Router, and performance improvements with practical implementation examples.",
    "authorId": "1",
    "category": "React",
    "tags": ["nextjs", "react", "server-components", "performance", "ssr", "web-development"],
    "publishedAt": "2024-02-18T09:45:00Z",
    "updatedAt": "2024-02-22T17:30:00Z",
    "readTime": 11,
    "likes": 421,
    "bookmarks": 210,
    "views": 7540,
    "featuredImage": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=1200&h=600&fit=crop",
    "isFeatured": true,
    "status": "published"
  },
  {
    "id": "7",
    "title": "JavaScript Performance Optimization: Modern Techniques",
    "content": "Modern JavaScript performance optimization goes beyond basic tips to include advanced techniques for today's complex web applications.\n\n## Memory Management\nAvoid memory leaks with proper cleanup:\n```javascript\n// Use WeakMap for cache\nconst cache = new WeakMap();\n\n// Clean up event listeners\nuseEffect(() => {\n  const handleResize = () => { /* ... */ };\n  window.addEventListener('resize', handleResize);\n  return () => window.removeEventListener('resize', handleResize);\n}, []);\n```\n\n## Code Splitting\nDynamic imports for better loading:\n```javascript\nconst HeavyComponent = React.lazy(() => \n  import('./HeavyComponent')\n);\n```\n\n## Web Workers\nOffload heavy computations:\n```javascript\nconst worker = new Worker('worker.js');\nworker.postMessage(data);\nworker.onmessage = (e) => {\n  console.log('Result:', e.data);\n};\n```\n\n## Performance Monitoring\n- Use Chrome DevTools\n- Implement Performance API\n- Set up Real User Monitoring\n- Lighthouse audits",
    "excerpt": "Advanced JavaScript performance techniques including memory management, code splitting, web workers, and modern optimization patterns.",
    "authorId": "2",
    "category": "JavaScript",
    "tags": ["javascript", "performance", "optimization", "web-development", "memory", "async"],
    "publishedAt": "2024-02-25T15:20:00Z",
    "updatedAt": "2024-03-01T10:15:00Z",
    "readTime": 8,
    "likes": 278,
    "bookmarks": 143,
    "views": 5120,
    "featuredImage": "https://images.unsplash.com/photo-1579468118864-1b9ea3c0db4a?w=1200&h=600&fit=crop",
    "isFeatured": false,
    "status": "published"
  }
]